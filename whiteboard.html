<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Whiteboard - Valiant Vision</title>
<style>
body {margin:0;font-family:'Lora', serif;background:#f4f4f7; display:flex; flex-direction:column; align-items:center;}
#whiteboard-container{max-width:1100px;margin:20px auto;padding:0 20px;width:100%;}
#whiteboard-tools{display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
#whiteboard-tools button, #whiteboard-tools input[type=color], #whiteboard-tools input[type=number]{padding:6px 12px; border-radius:8px; border:none; cursor:pointer;}
#whiteboard{border:2px solid #333; border-radius:12px; touch-action: none; width:100%; height:600px; background:#fff; display:block;}
</style>
</head>
<body>

<div id="whiteboard-container">
  <h2>Interactive Whiteboard</h2>
  <div id="whiteboard-tools">
    <button onclick="setTool('pen')">Pen</button>
    <button onclick="setTool('eraser')">Eraser</button>
    <button onclick="setTool('line')">Line</button>
    <button onclick="setTool('rect')">Rectangle</button>
    <button onclick="setTool('circle')">Circle</button>
    <button onclick="setTool('ellipse')">Ellipse</button>
    <button onclick="setTool('triangle')">Triangle</button>
    <button onclick="setTool('star')">Star</button>
    <button onclick="setTool('arrow')">Arrow</button>
    <button onclick="setTool('polygon')">Polygon</button>
    <button onclick="clearBoard()">Clear All</button>
    <label>Color: <input type="color" id="colorPicker" value="#000000"></label>
    <label>Width: <input type="number" id="widthPicker" value="3" min="1" max="50"></label>
  </div>
  <canvas id="whiteboard"></canvas>
</div>

<script>
const canvas = document.getElementById('whiteboard');
const ctx = canvas.getContext('2d');
let drawing = false, startX=0, startY=0;
let tool='pen', color='#000', width=3;
let tempCanvas = document.createElement('canvas');
let tempCtx = tempCanvas.getContext('2d');

// Resize canvas
function resizeCanvas(){
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Tools
function setTool(t){ tool=t; }
function clearBoard(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

// Drawing
function startDraw(e){
    drawing = true;
    const pos = getPos(e);
    startX=pos.x; startY=pos.y;
    if(tool==='pen' || tool==='eraser'){
        ctx.beginPath();
        ctx.moveTo(startX,startY);
    }
}

function draw(e){
    if(!drawing) return;
    const pos = getPos(e);
    color = document.getElementById('colorPicker').value;
    width = parseInt(document.getElementById('widthPicker').value);

    if(tool==='pen'){
        ctx.strokeStyle=color;
        ctx.lineWidth=width;
        ctx.lineCap='round';
        ctx.lineTo(pos.x,pos.y);
        ctx.stroke();
    } else if(tool==='eraser'){
        ctx.strokeStyle='#fff';
        ctx.lineWidth=width*2;
        ctx.lineCap='round';
        ctx.lineTo(pos.x,pos.y);
        ctx.stroke();
    } else {
        tempCtx.clearRect(0,0,tempCanvas.width,tempCanvas.height);
        tempCtx.drawImage(canvas,0,0);
        tempCtx.strokeStyle=color;
        tempCtx.lineWidth=width;
        tempCtx.setLineDash([5,5]); // preview
        const w=pos.x-startX, h=pos.y-startY;

        switch(tool){
            case 'line':
                tempCtx.beginPath(); tempCtx.moveTo(startX,startY); tempCtx.lineTo(pos.x,pos.y); tempCtx.stroke(); break;
            case 'rect': tempCtx.strokeRect(startX,startY,w,h); break;
            case 'circle': 
                tempCtx.beginPath(); let r=Math.sqrt(w*w+h*h); tempCtx.arc(startX,startY,r,0,2*Math.PI); tempCtx.stroke(); break;
            case 'ellipse':
                tempCtx.beginPath(); tempCtx.ellipse(startX,startY,Math.abs(w),Math.abs(h),0,0,2*Math.PI); tempCtx.stroke(); break;
            case 'triangle':
                tempCtx.beginPath(); tempCtx.moveTo(startX,startY); tempCtx.lineTo(startX+w,startY+h); tempCtx.lineTo(startX-w,startY+h); tempCtx.closePath(); tempCtx.stroke(); break;
            case 'star':
                drawStar(tempCtx,startX,startY,5,Math.sqrt(w*w+h*h)/2,Math.sqrt(w*w+h*h)/4); break;
            case 'arrow':
                drawArrow(tempCtx,startX,startY,pos.x,pos.y); break;
            case 'polygon':
                drawPolygon(tempCtx,startX,startY,6,Math.sqrt(w*w+h*h)); break;
        }
    }
}

function endDraw(e){
    if(!drawing) return;
    drawing=false;
    const pos=getPos(e);
    ctx.strokeStyle=color;
    ctx.lineWidth=width;
    ctx.setLineDash([]);
    const w=pos.x-startX, h=pos.y-startY;
    switch(tool){
        case 'line': ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(pos.x,pos.y); ctx.stroke(); break;
        case 'rect': ctx.strokeRect(startX,startY,w,h); break;
        case 'circle': ctx.beginPath(); let r=Math.sqrt(w*w+h*h); ctx.arc(startX,startY,r,0,2*Math.PI); ctx.stroke(); break;
        case 'ellipse': ctx.beginPath(); ctx.ellipse(startX,startY,Math.abs(w),Math.abs(h),0,0,2*Math.PI); ctx.stroke(); break;
        case 'triangle': ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(startX+w,startY+h); ctx.lineTo(startX-w,startY+h); ctx.closePath(); ctx.stroke(); break;
        case 'star': drawStar(ctx,startX,startY,5,Math.sqrt(w*w+h*h)/2,Math.sqrt(w*w+h*h)/4); break;
        case 'arrow': drawArrow(ctx,startX,startY,pos.x,pos.y); break;
        case 'polygon': drawPolygon(ctx,startX,startY,6,Math.sqrt(w*w+h*h)); break;
    }
}

// Utility
function getPos(e){
    const rect = canvas.getBoundingClientRect();
    let x,y;
    if(e.touches){ x=e.touches[0].clientX-rect.left; y=e.touches[0].clientY-rect.top;}
    else{ x=e.clientX-rect.left; y=e.clientY-rect.top;}
    return {x,y};
}

// Shape helpers
function drawStar(c,x,y,points,outer,rInner){
    const angle = Math.PI/points;
    c.beginPath();
    for(let i=0;i<2*points;i++){
        const r=i%2===0?outer:rInner;
        const a=i*angle-Math.PI/2;
        c.lineTo(x+r*Math.cos(a),y+r*Math.sin(a));
    }
    c.closePath(); c.stroke();
}

function drawArrow(c,x1,y1,x2,y2){
    const headLength=15;
    const dx=x2-x1, dy=y2-y1;
    const angle=Math.atan2(dy,dx);
    c.beginPath(); c.moveTo(x1,y1); c.lineTo(x2,y2);
    c.lineTo(x2-headLength*Math.cos(angle-Math.PI/6),y2-headLength*Math.sin(angle-Math.PI/6));
    c.moveTo(x2,y2);
    c.lineTo(x2-headLength*Math.cos(angle+Math.PI/6),y2-headLength*Math.sin(angle+Math.PI/6));
    c.stroke();
}

function drawPolygon(c,x,y,sides,r){
    c.beginPath();
    for(let i=0;i<sides;i++){
        const a=(2*Math.PI*i/sides)-Math.PI/2;
        const px=x+r*Math.cos(a), py=y+r*Math.sin(a);
        if(i===0) c.moveTo(px,py);
        else c.lineTo(px,py);
    }
    c.closePath(); c.stroke();
}

// Events
canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', endDraw);
canvas.addEventListener('mouseout', endDraw);
canvas.addEventListener('touchstart', startDraw);
canvas.addEventListener('touchmove', draw);
canvas.addEventListener('touchend', endDraw);

// Merge temp canvas
function mergeTemp(){ ctx.drawImage(tempCanvas,0,0); tempCtx.clearRect(0,0,tempCanvas.width,tempCanvas.height); }
setInterval(()=>{ if(!drawing) mergeTemp(); },50);
</script>

</body>
</html>
