<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Advanced Whiteboard</title>
<style>
  :root{
    --toolbar-bg:#ffffff;
    --primary:#2563eb;
    --accent:#1d976c;
    --note-bg:#fff59d;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#f3f6fb}
  #board{position:fixed;inset:0;background:#fff;touch-action:none;display:block}
  .toolbar{
    position:fixed;left:50%;top:14px;transform:translateX(-50%);
    display:flex;gap:8px;flex-wrap:wrap;z-index:2000;
    background:var(--toolbar-bg);padding:10px;border-radius:12px;
    box-shadow:0 6px 20px rgba(12,20,40,0.12);
  }
  .toolbar *{font-size:14px}
  button, select, input[type=color], input[type=range]{
    border:0;padding:8px 10px;border-radius:8px;cursor:pointer;
    background:#eef2ff;color:#0f172a;font-weight:600;
  }
  button.primary{background:var(--primary);color:#fff}
  button.warn{background:#ef4444;color:#fff}
  input[type=color]{padding:4px}
  input[type=range]{width:110px}
  .note{
    position:absolute;background:var(--note-bg);border:1px solid #444;padding:0;border-radius:8px;
    min-width:120px;min-height:80px;z-index:1500;box-shadow:0 6px 18px rgba(0,0,0,0.12);
    display:flex;flex-direction:column;overflow:hidden;
  }
  .note .hdr{background:rgba(0,0,0,0.06);padding:6px 8px;cursor:grab;display:flex;justify-content:space-between;gap:8px;align-items:center}
  .note textarea{flex:1;border:0;padding:8px;resize:none;background:transparent;outline:none;font-size:14px}
  .selected-outline{
    position:absolute;border:2px dashed rgba(220,20,60,0.9);pointer-events:none;z-index:1600;
  }
  .handle{
    position:absolute;width:12px;height:12px;background:#fff;border:2px solid #444;border-radius:2px;box-sizing:border-box;z-index:1601;
  }
  /* mobile spacing */
  @media (max-width:520px){
    .toolbar{left:10px;transform:none;top:10px}
  }
</style>
</head>
<body>
<canvas id="board"></canvas>

<div class="toolbar" id="toolbar">
  <select id="tool">
    <option value="pen">‚úè Pen</option>
    <option value="line">üìè Line</option>
    <option value="rect">‚¨õ Rect</option>
    <option value="circle">‚ö™ Circle</option>
    <option value="eraser">ü©π Eraser</option>
    <option value="select">üî≤ Select</option>
  </select>

  <input type="color" id="colorPicker" value="#000000" title="Color"/>
  <input type="range" id="sizePicker" min="1" max="30" value="3" title="Size"/>

  <button onclick="addNote()">üìù Note</button>
  <button onclick="deleteSelected()">‚ùå Delete</button>
  <button class="primary" onclick="clearBoard()">üßπ Clear</button>
</div>

<script>
/* ====== Core setup ====== */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.style.touchAction = 'none'; // prevent default scrolling when touching canvas

function fitCanvas(){
  // preserve contents by redrawing from shapes after resize
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  redraw();
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ====== State ====== */
let tool = 'pen';
let color = '#000000';
let size = 3;
let drawing = false;
let pointerId = null;
let startX=0, startY=0;
let temporary = null; // used for preview shape
let shapes = []; // array of shape objects
let selected = null; // {type:'shape'|'note', obj: ref}
let dragState = null; // {mode:'move'|'resize'|'draw'|'note-drag', ...}

/* shape object formats:
 pen: {type:'pen', color, size, points:[[x,y],...]}
 line: {type:'line', color, size, x1,y1,x2,y2}
 rect: {type:'rect', color, size, x1,y1,x2,y2}
 circle: {type:'circle', color, size, x1,y1,x2,y2} // center x1,y1 radius defined by x2,y2
*/

/* ====== Toolbar bindings ====== */
document.getElementById('tool').addEventListener('change', e=>{
  tool = e.target.value; selected = null; removeSelectionUI();
});
document.getElementById('colorPicker').addEventListener('input', e=> color = e.target.value);
document.getElementById('sizePicker').addEventListener('input', e=> size = +e.target.value);

/* ====== Pointer events (works for mouse + touch) ====== */
canvas.addEventListener('pointerdown', pointerDown);
canvas.addEventListener('pointermove', pointerMove);
canvas.addEventListener('pointerup', pointerUp);
canvas.addEventListener('pointercancel', pointerUp);
canvas.addEventListener('pointerleave', pointerUp);

function getEvPos(ev){
  const rect = canvas.getBoundingClientRect();
  return {x: ev.clientX - rect.left, y: ev.clientY - rect.top};
}

/* ====== Drawing & preview logic ====== */
function pointerDown(ev){
  // ignore secondary buttons
  if(ev.button && ev.button !== 0) return;
  canvas.setPointerCapture(ev.pointerId);
  pointerId = ev.pointerId;
  const p = getEvPos(ev);
  startX = p.x; startY = p.y;
  drawing = true;

  if(tool === 'pen'){
    const obj = {type:'pen', color, size, points:[[p.x,p.y]]};
    shapes.push(obj);
    dragState = {mode:'draw', obj};
  } else if(tool === 'eraser'){
    // implement eraser as live clear rect and also record to shapes? we'll just perform clear on canvas and leave shapes unaffected
    dragState = {mode:'eraser'};
    eraseAt(p.x,p.y,size);
  } else if(tool === 'select'){
    // detect hit on shapes from top -> bottom
    const hit = hitTestShape(p.x,p.y);
    if(hit){ // select shape
      selectShape(hit.shape);
      // start dragging
      dragState = {mode:'move-shape', offsetX: p.x, offsetY: p.y};
    } else {
      // check if clicked on note (DOM element)
      const noteEl = getNoteAtPoint(p.x, p.y);
      if(noteEl){ selectNote(noteEl); dragState = {mode:'note-drag', startX:p.x, startY:p.y, note:noteEl, initLeft: parseFloat(noteEl.style.left), initTop: parseFloat(noteEl.style.top)}; }
      else { deselectAll(); }
    }
  } else if(tool === 'line' || tool === 'rect' || tool === 'circle'){
    // start preview
    temporary = {type:tool, color, size, x1:startX, y1:startY, x2:startX, y2:startY};
    dragState = {mode:'draw-temp', temp:temporary};
  } else if(tool === 'note'){
    // not used - we use button addNote()
  }
}

function pointerMove(ev){
  if(!drawing || ev.pointerId !== pointerId) return;
  const p = getEvPos(ev);
  if(dragState && dragState.mode === 'draw'){
    // pen drawing
    const o = dragState.obj;
    o.points.push([p.x,p.y]);
    redraw();
    return;
  }
  if(dragState && dragState.mode === 'eraser'){
    eraseAt(p.x,p.y,size);
    return;
  }
  if(dragState && dragState.mode === 'draw-temp'){
    temporary.x2 = p.x; temporary.y2 = p.y;
    redraw();
    drawPreview(temporary);
    return;
  }
  if(dragState && dragState.mode === 'move-shape'){
    // move selected shape by delta
    if(!selected || selected.type !== 'shape') return;
    const dx = p.x - dragState.offsetX;
    const dy = p.y - dragState.offsetY;
    moveShape(selected.obj, dx, dy);
    dragState.offsetX = p.x; dragState.offsetY = p.y;
    redraw(); showSelectionOutline(selected.obj);
    return;
  }
  if(dragState && dragState.mode === 'note-drag'){
    const n = dragState.note;
    const dx = p.x - dragState.startX;
    const dy = p.y - dragState.startY;
    n.style.left = (dragState.initLeft + dx) + 'px';
    n.style.top = (dragState.initTop + dy) + 'px';
    return;
  }
}

function pointerUp(ev){
  if(ev.pointerId !== pointerId) return;
  canvas.releasePointerCapture(ev.pointerId);
  const p = getEvPos(ev);
  if(dragState && dragState.mode === 'draw'){
    // finish pen
    dragState = null; drawing=false; temporary=null;
    redraw();
    return;
  }
  if(dragState && dragState.mode === 'draw-temp'){
    // finalize shape object
    shapes.push({...temporary}); temporary = null; dragState=null; drawing=false;
    redraw();
    return;
  }
  if(dragState && dragState.mode === 'eraser'){ dragState=null; drawing=false; return; }
  if(dragState && dragState.mode === 'move-shape'){ dragState=null; drawing=false; return; }
  if(dragState && dragState.mode === 'note-drag'){ dragState=null; drawing=false; return; }

  drawing = false;
  pointerId = null;
}

/* ====== Redraw all shapes ====== */
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw shapes in order
  for(const s of shapes){
    ctx.strokeStyle = s.color;
    ctx.lineWidth = s.size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    if(s.type === 'pen'){
      if(!s.points || s.points.length===0) continue;
      ctx.moveTo(s.points[0][0], s.points[0][1]);
      for(let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i][0], s.points[i][1]);
      ctx.stroke();
    } else if(s.type === 'line'){
      ctx.moveTo(s.x1, s.y1); ctx.lineTo(s.x2, s.y2); ctx.stroke();
    } else if(s.type === 'rect'){
      ctx.strokeRect(s.x1, s.y1, s.x2 - s.x1, s.y2 - s.y1);
    } else if(s.type === 'circle'){
      const r = Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
      ctx.beginPath(); ctx.arc(s.x1, s.y1, r, 0, Math.PI*2); ctx.stroke();
    }
  }

  // if a temporary preview exists while drawing (dotted)
  if(temporary) drawPreview(temporary);

  // update selection outline UI
  if(selected && selected.type === 'shape') showSelectionOutline(selected.obj);
}

/* ====== Preview drawing (dotted rubberband) ====== */
function drawPreview(s){
  ctx.save();
  ctx.setLineDash([6,6]);
  ctx.strokeStyle = s.color;
  ctx.lineWidth = s.size;
  ctx.beginPath();
  if(s.type === 'line'){ ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke(); }
  else if(s.type === 'rect'){ ctx.strokeRect(s.x1,s.y1,s.x2-s.x1,s.y2-s.y1); }
  else if(s.type === 'circle'){ const r = Math.hypot(s.x2-s.x1,s.y2-s.y1); ctx.beginPath(); ctx.arc(s.x1,s.y1,r,0,Math.PI*2); ctx.stroke(); }
  ctx.restore();
}

/* ====== Helpers: erase, hit-test, move shape ====== */
function eraseAt(x,y,sz){
  ctx.clearRect(x - sz, y - sz, sz*2, sz*2);
  // visually erase; but shapes data remain ‚Äî optionally we could rasterize or remove parts of pen strokes (not implemented)
}

function hitTestShape(x,y){
  // iterate from topmost (end) to start
  for(let i = shapes.length-1;i>=0;i--){
    const s = shapes[i];
    if(s.type === 'pen'){
      // hit if inside bounding box with margin
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const p of s.points){ minX=Math.min(minX,p[0]); minY=Math.min(minY,p[1]); maxX=Math.max(maxX,p[0]); maxY=Math.max(maxY,p[1]); }
      if(x >= minX-8 && x <= maxX+8 && y>=minY-8 && y<=maxY+8) return {shape:s, index:i};
    } else if(s.type === 'line'){
      // distance to segment
      if(pointNearLine(x,y,s.x1,s.y1,s.x2,s.y2, Math.max(6, s.size+4))) return {shape:s,index:i};
    } else if(s.type === 'rect'){
      if(x>=Math.min(s.x1,s.x2)-4 && x<=Math.max(s.x1,s.x2)+4 && y>=Math.min(s.y1,s.y2)-4 && y<=Math.max(s.y1,s.y2)+4) return {shape:s,index:i};
    } else if(s.type === 'circle'){
      const r = Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
      const d = Math.hypot(x - s.x1, y - s.y1);
      if(Math.abs(d - r) <= Math.max(6, s.size+4)) return {shape:s,index:i};
    }
  }
  return null;
}

function pointNearLine(px,py,x1,y1,x2,y2,thresh){
  // distance from point to segment
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const len_sq = C*C + D*D;
  let param = len_sq !== 0 ? dot / len_sq : -1;
  let xx, yy;
  if(param < 0){ xx = x1; yy = y1; }
  else if(param > 1){ xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy;
  return Math.hypot(dx,dy) <= thresh;
}

function moveShape(s,dx,dy){
  if(s.type === 'pen'){
    for(const p of s.points){ p[0]+=dx; p[1]+=dy; }
  } else {
    s.x1 += dx; s.y1 += dy; s.x2 += dx; s.y2 += dy;
  }
}

/* ====== Selection UI for shapes (outline + handles) ====== */
let outlineEl = null;
let handleEls = [];

function removeSelectionUI(){
  if(outlineEl){ outlineEl.remove(); outlineEl=null; }
  for(const h of handleEls) h.remove();
  handleEls = [];
}

function showSelectionOutline(s){
  removeSelectionUI();
  // compute bounding box
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  if(s.type === 'pen'){
    for(const p of s.points){ minX=Math.min(minX,p[0]); minY=Math.min(minY,p[1]); maxX=Math.max(maxX,p[0]); maxY=Math.max(maxY,p[1]); }
  } else if(s.type === 'line'){
    minX = Math.min(s.x1,s.x2); minY = Math.min(s.y1,s.y2); maxX = Math.max(s.x1,s.x2); maxY = Math.max(s.y1,s.y2);
  } else {
    minX = Math.min(s.x1,s.x2); minY = Math.min(s.y1,s.y2); maxX = Math.max(s.x1,s.x2); maxY = Math.max(s.y1,s.y2);
  }
  // create outline div
  outlineEl = document.createElement('div');
  outlineEl.className = 'selected-outline';
  outlineEl.style.left = (minX - 6) + 'px';
  outlineEl.style.top  = (minY - 6) + 'px';
  outlineEl.style.width = (Math.max(6, maxX - minX) + 12) + 'px';
  outlineEl.style.height = (Math.max(6, maxY - minY) + 12) + 'px';
  document.body.appendChild(outlineEl);

  // create 4 handles (tl,tr,bl,br)
  const coords = [
    {x:minX-8,y:minY-8,c:'nw'},
    {x:maxX+4,y:minY-8,c:'ne'},
    {x:minX-8,y:maxY+4,c:'sw'},
    {x:maxX+4,y:maxY+4,c:'se'},
  ];
  handleEls = coords.map((pt,idx)=>{
    const h = document.createElement('div'); h.className='handle'; document.body.appendChild(h);
    h.style.left = pt.x+'px'; h.style.top = pt.y+'px';
    h.dataset.anchor = pt.c;
    // pointer handling for resize
    h.addEventListener('pointerdown', (ev)=>{
      ev.stopPropagation(); ev.preventDefault();
      canvas.setPointerCapture(ev.pointerId);
      dragState = {mode:'resize-shape', shape:selected.obj, anchor:h.dataset.anchor, startX:ev.clientX, startY:ev.clientY};
    });
    return h;
  });
}

/* ====== Selecting shapes & notes ====== */
function selectShape(s){
  selected = {type:'shape', obj:s};
  showSelectionOutline(s);
}
function deselectAll(){ selected=null; removeSelectionUI(); document.querySelectorAll('.note').forEach(n=>n.classList.remove('selected')); }

function getNoteAtPoint(x,y){
  // notes are DOM elements with class 'note'
  const notes = document.querySelectorAll('.note');
  for(const n of notes){
    const r = n.getBoundingClientRect();
    if(x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return n;
  }
  return null;
}

/* ====== Notes creation & drag ====== */
function addNote(left=120,top=120){
  const note = document.createElement('div');
  note.className='note';
  note.style.left = (left)+'px';
  note.style.top = (top)+'px';
  note.style.width = '180px';
  note.style.height = '120px';
  note.innerHTML = `
    <div class="hdr">
      <div style="font-weight:700">Note</div>
      <div style="display:flex;gap:6px">
        <button style="padding:4px 6px" title="Delete" onclick="(function(e){ e.stopPropagation(); note.remove(); deselectAll(); })(event)">‚úñ</button>
      </div>
    </div>
    <textarea placeholder="Type notes..." style="width:100%;height:100%;box-sizing:border-box;"></textarea>
  `;
  // header drag
  const hdr = note.querySelector('.hdr');
  hdr.addEventListener('pointerdown', e=>{
    e.stopPropagation(); e.preventDefault();
    const startX = e.clientX, startY = e.clientY;
    const initLeft = parseFloat(note.style.left), initTop = parseFloat(note.style.top);
    function move(ev){ note.style.left = (initLeft + ev.clientX - startX)+'px'; note.style.top = (initTop + ev.clientY - startY)+'px'; }
    function up(){ window.removeEventListener('pointermove', move); window.removeEventListener('pointerup', up); }
    window.addEventListener('pointermove', move); window.addEventListener('pointerup', up);
  });
  // select on click
  note.addEventListener('pointerdown', e=>{
    e.stopPropagation();
    deselectAll();
    note.classList.add('selected');
    selected = {type:'note', obj:note};
  });
  document.body.appendChild(note);
}

/* ====== Delete & Clear functions ====== */
function deleteSelected(){
  if(!selected) return;
  if(selected.type === 'note'){
    selected.obj.remove(); selected=null; removeSelectionUI();
  } else if(selected.type === 'shape'){
    const idx = shapes.indexOf(selected.obj);
    if(idx>=0) shapes.splice(idx,1);
    selected=null; removeSelectionUI(); redraw();
  }
}

function clearBoard(){
  shapes = [];
  redraw();
  document.querySelectorAll('.note').forEach(n => n.remove());
  selected = null;
  removeSelectionUI();
}

/* ====== Resize logic for shapes via dragState ====== */
window.addEventListener('pointermove', (ev)=>{
  if(!dragState) return;
  if(dragState.mode === 'resize-shape'){
    // compute delta in canvas coords
    const rect = canvas.getBoundingClientRect();
    const dx = ev.clientX - dragState.startX;
    const dy = ev.clientY - dragState.startY;
    // modify shape coords according to anchor
    const s = dragState.shape;
    // convert dx/dy to canvas space (same coordinate space)
    if(dragState.anchor === 'nw'){ s.x1 += dx; s.y1 += dy; }
    if(dragState.anchor === 'ne'){ s.x2 += dx; s.y1 += dy; }
    if(dragState.anchor === 'sw'){ s.x1 += dx; s.y2 += dy; }
    if(dragState.anchor === 'se'){ s.x2 += dx; s.y2 += dy; }
    dragState.startX = ev.clientX; dragState.startY = ev.clientY;
    redraw(); showSelectionOutline(s);
  }
});
// finalize resize on pointerup
window.addEventListener('pointerup', (ev)=>{
  if(dragState && dragState.mode === 'resize-shape') { dragState = null; }
});

/* ====== Hit test for clicking shapes (selection) on pointerup when tool=select and not dragging ====== */
canvas.addEventListener('click', (ev)=>{
  if(tool !== 'select') return;
  const p = getEvPos(ev);
  // if we are drawing or dragging skip
  if(dragState) return;
  const hit = hitTestShape(p.x,p.y);
  if(hit){ selectShape(hit.shape); }
  else {
    const note = getNoteAtPoint(p.x,p.y);
    if(note){ selectNote(note); } else { deselectAll(); }
  }
});

function selectNote(n){
  deselectAll();
  n.classList.add('selected');
  selected = {type:'note', obj:n};
}

/* ====== Utility: export & import (optional) ====== */
// You can add functions to save shapes (JSON) or export canvas image. (not included by default)

/* ====== Initialize small demo shapes (optional) ====== */
// none by default

/* ====== Accessibility: keyboard delete ====== */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'Delete' || e.key === 'Backspace'){ deleteSelected(); }
});

/* ====== Touch behavior note ====== */
// The app uses pointer events and sets touch-action none, which makes drawing on mobile smooth.
// If your device has odd gestures (two-finger zoom), you may need additional meta tags or CSS not to block them.

</script>
</body>
</html>
